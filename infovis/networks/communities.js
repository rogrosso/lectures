import { keyCantor } from "../../common/utilities.js"

/**
 * Implements the Louvain algorithm for community detection
 * Works on undirected graphs. It assumes that undirected edges are given only once, the adjacency matrix
 * is symmetric and will include both directions. Edges are weighted.
 * @param {Array} nodes, node array
 * @param {Array} edges, edge array
 * @returns {Number} number of communities
 */
export function louvain(nodes, edges) {
    let A_ = new Array(nodes.length).fill(null).map((e) => [])
    let m = 0
    for (let e of edges) {
        m += e.weight
        A_[e.source].push({index: e.target, weight: e.weight}) // the graph is undirected
        A_[e.target].push({index: e.source, weight: e.weight}) // use weights for convenience
    }
    const n = nodes.length
    // initialize nodes
    const n_ = []
    for (let n of nodes){
        n_.push({ 
            index: n.index, 
            c: n.index, // community
            k: n.degree, // total degree in undirected graph
            loop: 0, // number/weight of self loop, i.e. degree is 2 * loop 
            children: null, // children in tree generated by louvain algorithm
            parent: null // parent in tree generated by louvain algorithm
        })
    }
    let cFlag = true
    let mFlag = true
    let maxIter = 10
    while (cFlag && mFlag && maxIter > 0) {
        maxIter--
        // partition network into communities
        const q_ = init(n_)
        const mod1 = computeModularity(m, q_)
        cFlag = partition(A_, n_, q_, m)
        const mod2 = computeModularity(m, q_)
        if (mod2 <= mod1) {
            mFlag = false
        } else {
            agglomerate(q_, n_, A_)
        }
    }
    propagate(n_, nodes)
    return n_.length
}
/**
 * Initialize communities. Each node is a community.
 * @param {Array} n_, nodes
 * @returns {Map} map of nodes with community as key and nodes as value
 */
function init(n_) {
    const q_ = new Map()
    for (let n of n_) {
        if (q_.has(n.c)) {
            q_.get(n.c).nodes.add(n)
        } else {
            const nSet = new Set()
            nSet.add(n)
            q_.set(n.c, { 
                c: n.c, // community index
                nodes: nSet, // nodes in the community
                sIn: n.loop, // sum of the weights of the links inside the community
                sTot: n.k //+ n.loop //+ 2 * n.loop // total number of links/weights of all nodes in the community
            } )
        }
    }
    return q_
}
/**
 * Agglomerate communities into super nodes and compute the adjacency matrix of super nodes
 * and loops giving the links between nodes in the communities before agglomeration.
 * The degree of the super nodes already contains the loops.
 * @param {Map} q_, communities
 * @param {Array} n_, nodes
 * @param {Array} A_, adjacency matrix
 */
function agglomerate(q_, n_, A_) {
    const c_ = [] // super nodes
    const e_ = new Map() // super edges
    let index = 0
    for (let [key, value] of q_) {
        if (value.nodes.size > 0) {
            c_.push({
                index,
                c: key,
                k: value.sTot,
                loop: value.sIn
            })
            e_.set(key, {index: index, c: key, nodes: value.nodes})
            index++
        }
    }
    // compute adjacency matrix of super nodes
    const m_ = new Map() // super edges map
    for (let [key, value] of e_) {
        const i1 = value.index
        const c1 = value.c
        for (let n of value.nodes) {
            // collect all neighbors of this node 
            for (let e of A_[n.index]) {
                if (c1 !== n_[e.index].c) {
                    const i2 = e_.get(n_[e.index].c).index
                    const k_ = keyCantor(i1, i2)
                    if (m_.has(k_)) {
                        m_.get(k_).weight += e.weight
                    } else {
                        m_.set(k_, { source: i1, target: i2, weight: e.weight })
                    }
                }
            }
        }
    }
    // compute adjacency matrix of super nodes
    const A = new Array(c_.length).fill(null).map((e) => [])
    for (let [key, value] of m_) {
        A[value.source].push({index: value.target, weight: value.weight/2})
        A[value.target].push({index: value.source, weight: value.weight/2})
    }
    // copy back to n_ and A_
    n_.length = 0
    A_.length = 0
    for (let c of c_) {
        n_.push({
            index: c.index,
            c: c.c,
            k: c.k,
            loop: c.loop,
            children: e_.get(c.c).nodes,
            parent: null,
        })
    }
    for (let i = 0; i < A.length; i++) {
        A_.push([])
        for (let j = 0; j < A[i].length; j++) {
            A_[i].push({index: A[i][j].index, weight: A[i][j].weight})
        }
    }
    for (let n of n_) {
        for(let e of n.children) {
            e.parent = n
        }
    }
}
/**
 * Partition a network into communities based on gain in modularity.
 * @param {Array} A, adjacency matrix
 * @param {Array} n_, nodes
 * @param {Map} q_, communities
 * @param {Number} m, total weight of all edges 
 * @returns {Boolean} true if a node has changed its community
 */
function partition(A, n_, q_, m) {
    let flag = true
    let cFlag = false
    while(flag) {
        flag = false
        for (let i = 0; i < n_.length; i++) {
            let deltaQ = 0 // modularity gain must be positive
            const c_ = computeC(A, n_, i)
            let inDeltaQ = undefined
            const outDeltaQ = computeOutDeltaQ(q_, m, A, n_, i) // this is the cost of removing i from its own community
            let nodeC = n_[i].c
            for (let c of c_) {
                const inGain = computeInDeltaQ(q_, m, A, n_, i, c) // add i to community c
                const gain = computeDeltaQ(m, n_[i].k, n_[i].loop, inGain, outDeltaQ)
                if (gain > deltaQ) {
                    nodeC = c
                    inDeltaQ = inGain
                    deltaQ = gain
                }
            }
            if (nodeC !== n_[i].c) {
                const C_ = q_.get(nodeC) // move node i to community C (index nodeC)
                const D_ = q_.get(n_[i].c)   // remove node i from community D (index n_[i].c)
                D_.nodes.delete(n_[i])
                D_.sIn -= ( 2 * outDeltaQ.k_iD + n_[i].loop ) // this is the adjacency of i with its own community D_
                D_.sTot -= n_[i].k // we count only the degree
                C_.nodes.add(n_[i])
                C_.sIn += ( 2 * inDeltaQ.k_iC + n_[i].loop ) // this is the adjacency of i with nodes in community C_
                C_.sTot += n_[i].k // we count only the degree
                n_[i].c = nodeC // move node i to community c
                flag = true
                cFlag = true
            }
        }
    }
    return cFlag
}
/**
 * Propagate community index from super nodes to its children nodes. The implementation is recursive.
 * @param {Array} n_, node array with community index
 * @param {Array} nodes, input node array, we need to update the group (community) index
 */
function propagate(n_, nodes) {
    let group = 0
    for (let n of n_) {
        propagate_(n, group, nodes)
        group++
    }
}
/**
 * Recursive function to propagate community index from super nodes to its children nodes.
 * @param {Array} n, nodes
 * @param {Number} group, group index 
 * @param {Array} nodes, input node array, we need to update the group (community) index 
 * @returns 
 */
function propagate_(n, group, nodes) {
    n.group = group
    if (n.children === null) {
        nodes[n.index].group = group
        return
    } else {
        for (let c of n.children) {
            propagate_(c, group, nodes)
        }
    }
}

/**
 * Compute the communities that are connected to node i
 * @param {Array} A adjacency list
 * @param {Array} n_ node array
 * @param {Number} i node index
 */
function computeC(A, n_, i) {
    const s_ = new Set()
    const neighbors = A[i]
    for (let n of neighbors) {
        if (n_[n.index].c !== n_[i].c) {
            s_.add(n_[n.index].c)
        }
    }
    return s_.values()
}
/**
 * Compute the cost of moving node i to community c
 * We need to compute k_iC, the sum of the weights of the links from node i to nodes in community c.
 * We also need to compute sIn, the sum of the weights of the links inside community c before the node
 * i is added to the community.
 * @param {Array} A adjacency list
 * @param {Array} n_ node array
 * @param {Number} i node index
 * @param {Number} n nodes in the community c
 * @returns {Number} the cost of moving node i to community c
 */
function computeInDeltaQ(q_, m, A, n_, i, c) {
    const neighbors = A[i]
    let k_iC = 0
    let sTot = 0
    for (let n of neighbors) {
        if (n_[n.index].c === c) {
            k_iC += n.weight // weight of the links from node i to nodes in community c
        }
    }
    const C_ = q_.get(c)
    sTot = C_.sTot
    return {
        sTot,
        k_iC,
        in_loop: n_[i].loop
    }
}
/**
 * Compute the cost of removing node i from its own community
 * Compute the cost of moving node i out of community D
 * We need to compute k_i( i -> D), this is the number of links from i to nodes in its own community
 * members in D.
 * We also need to compute sTot, this is the total number of links from nodes in D to all nodes in the network,
 * before node i is removed.
 * @param {Array} A adjacency list, A[i] is the neighbors of node i and we assume the diagonal is 0!
 * @param {Array} n_ node array
 * @param {Number} i node index
 * @returns {Object} {sTot, k_iD}, where k_iD is the number of links from i to nodes in its own community
 */
function computeOutDeltaQ(q_, m, A, n_, i) {
    const c = n_[i].c // community of node i
    const neighbors = A[i] // neighbors of 
    let sTot = 0 // total degree of nodes in community D
    let k_iD = 0 // number of links from i to nodes in its own community
    for (let n of neighbors) {
        if (n_[n.index].c === n_[i].c) {
            k_iD += n.weight // number of links from i to nodes in its own community
        }
    }
    const D_ = q_.get(c)
    sTot = D_.sTot
    return {
        sTot,
        k_iD,
        out_loop: n_[i].loop
    }
}
/**
 * Compute the modularity gain
 * @param {Number} m number of edges in the network
 * @param {Object} inDeltaQ {sTot, k_iC}
 * @param {Object} outDeltaQ {sTot, k_iD}
 * @returns {Number} the modularity gain
 */
function computeDeltaQ(m, ki, loop, inDeltaQ, outDeltaQ) {
    const { sTot: sTotIn, k_iC } = inDeltaQ
    const { sTot: sTotOut, k_iD } = outDeltaQ
    const k = ki
    const deltaQ = (k_iC - k_iD) / m - k * (sTotIn - sTotOut + k) / (2 * m * m)
    return deltaQ
}
/**
 * Compute the modularity
 * @param {Array} m number of edges in the network
 * @param {Map} q_ communities
 */
function computeModularity(m, q_) {
    let Q = 0
    for (let c of q_.values()) {
        Q += (c.sIn - ( c.sTot * c.sTot ) / (2 * m)) / (2 * m)
    }
    return Q
}